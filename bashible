#!/bin/bash

# bashible
# (c) Jan Molic 2015
# https://github.com/mig1984/bashible


### INTERNAL FUNCTIONS ####

help() {
  echo "usage: bashible BLEBOOK.ble"
  echo
  echo "see also: https://github.com/mig1984/bashible"
  echo
  exit 1
}

# searches an array for an element; used internally
containsElement() {
  local e
  for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
  return 1
}

# export preserved variables
preserveEnvironment() {
  IFS=':'; for i in $_PRESERVED; do
     if [ -n "$i" ]; then
        export "$i"
     fi
  done
  IFS=$' \t\n'
}

# build _ENVREPEAT array
buildENVREPEAT() {
  _ENVREPEAT=()
  _ENVREPEAT[0]="env"
  local cnt=1
  IFS=':'; for i in $_PRESERVED; do
     IFS=$' \t\n'
     if [ -n "$i" ]; then
        _ENVREPEAT["$cnt"]="$i=`eval echo \\$$i`"
        let cnt=cnt+1
     fi
  done
  #echo "${_ENVREPEAT[@]}"
}

print_start() {
    echo -e "\n\033[1;37;45m ${_NAV} \033[1;37;44m START \033[0m"
}

print_block() {
    echo -e "\n\033[1;37;45m ${_NAV} \033[1;37;44m $* \033[0m"
}

print_finish() {
    echo -e "\n\033[1;37;45m ${_NAV} \033[1;37;44m FINISH \033[0m"
}

print_task() {
    echo -e "\033[37m - $* \033[0m"
}


### CORE FUNCTIONS ###

# represents a block; always chdirs to the base_dir (default = current directory)
@() {
   _BLOCKS_STARTED=1
   _SKIP=0
   cd "${_BASE_DIR}" || fail "can't chdir to base dir '${_BASE_DIR}'"
   print_block $*
}

# represents a task; if the task fails, the bashible script is stopped
# if the block has been skipped, does nothing
-() {
   if [ "${_SKIP}" != 1 ]; then
     print_task $*
     "$@" || fail "'$@' failed (in `pwd`)";
   fi
}

already() {
  if [ "${_BLOCKS_STARTED}" = 0 ]; then
     warn "already, stopping here"
     print_finish
     exit
  else
     info "already, skipping following tasks"
     _SKIP=1
  fi
}

# the same as skip_if, just a different message
already_if() {
  "$@" && already || return 0
}

# run following command as an user
as() {
   local user=$1; shift
   # can't be -i (login shell) otherwise it would chdir to homedir
   # and relative paths would behave unexpectedly
   buildENVREPEAT
   sudo -u "$user" "${_ENVREPEAT[@]}" "${_BASHIBLE}" -- "$@" || fail "sudo command failed (in `pwd`)"
}

# set base dir (will be chdired to it on each @ block)
base_dir() {
  _BASE_DIR=`readlink -e "$1"` # get absolute path
  if [ -z "${_BASE_DIR}" ]; then
    fail "base_dir: readlink -e '$1' failed"
  fi
}

# use to call a bashible "playbook" instead of sourcing it
# by default, calls only once unless forced
# call './foo.ble' [force]
call() {
  local path=`readlink -e "$1"` # get absolute path
  if [ -z "$path" ]; then
    fail "is the path of call '$1' correct at that place? (got empty path on readlink)"
  fi
  if [ "$2" != force ] && grep -q "$path" "${_CALLED}"; then
    # called already
    return
  fi
  echo $path >> "${_CALLED}" || fail "can't write to _CALLED file (${_CALLED})"
  (
    _NAV="${_NAV}/`basename $1 | sed "s/\.ble\$//" `"
    _BASE_DIR=`dirname "$path"`
    _ORIG_BASE_DIR="${_BASE_DIR}"
    _BLOCKS_STARTED=0
    _SKIP=0
    _IS_CHILD=1
    print_start
    cd "${_BASE_DIR}" || fail "can't enter base dir '${_BASE_DIR}'"
    source ./`basename "$1"` || fail "there's an error in the playbook"
    print_finish
  ) || exit 1
}

fail() {
   echo -e "\033[1;37;41m ${_NAV}: $*, exiting \033[0m"
   exit 1
}

import() {
   local path=`readlink -e "$1"` # get absolute path
   if ! echo "${_IMPORTED}" | grep ":$path:"; then
      _IMPORTED="${_IMPORTED}$path:"
      source "$path"
   fi
}

info() {
  echo -e "   \033[32m($*)\033[0m"
}

i_am_child() {
  [ -n "${_IS_CHILD}" ]
}

may_fail() {
  "$@"
  return 0
}

# opposite to only_on
not_on() {
   if containsElement "${_HOSTNAME}" "$@"; then
      if [ "${_BLOCKS_STARTED}" = 0 ]; then
         warn "skipping all tasks here on ${_HOSTNAME}"
         stop
      else
         warn "not on ${_HOSTNAME}, skipping"
         _SKIP=1
      fi
   fi
}

not() {
  "$@" && return 1 || return 0
}

notify_call() {
  readlink -e "$1" >> "${_NOTIFY}" || fail "can't write to _NOTIFY file (${_NOTIFY})"
}

# skip next tasks if the current hostname is not in defined
# if called before all blocks, can skip all of them
only_on() {
   if ! containsElement "${_HOSTNAME}" "$@"; then
      if [ "${_BLOCKS_STARTED}" = 0 ]; then
         warn "skipping all tasks here on ${_HOSTNAME}"
         stop
      else
         warn "not on ${_HOSTNAME}, skipping"
         _SKIP=1
      fi
   fi
}

var() {
   if var_is_empty "$1"; then
      fail "variable $1 is empty"
   fi
   _PRESERVED="${_PRESERVED}$1:"
   export "$1"
}

quiet() {
   "$@" >/dev/null 2>&1
}

reset_base_dir() {
  _BASE_DIR="${_ORIG_BASE_DIR}"
}

skip() {
   if [ "${_BLOCKS_STARTED}" = 0 ]; then
     info "skipping all tasks of the blebook"
     exit
   else
      info "skipping following tasks"
     _SKIP=1
   fi
}

skip_if() {
  "$@" && skip || return 0
}

stop() {
  info "stopping execution of the blebook"
  print_finish
  exit 0
}

stop_all() {
  info "stopping execution of the blebook and all parent blebooks"
  print_finish
  exit 1
}

stop_all_if() {
  "$@" && stop_all || return 0
}

stop_if() {
  "$@" && stop || return 0
}

# skip next tasks if the tag is not in required tags (passed as TAGS env variable; tags separated by comma)
tag() {
   IFS=',';  local ary=($TAGS);  IFS=$' \t\n'
   if [ "${#ary[@]}" -gt 0 ]; then
     if ! containsElement "$1" "${ary[@]}"; then
       warn "does not match tags, skipping"
       _SKIP=1
     fi
   fi
}

warn() {
  echo -e "   \033[31m($*)\033[0m"
}

when() {
   if eval "$1"; then
      shift
      "$@"
   fi
}

unless() {
   if ! eval "$1"; then
      shift
      "$@"
   fi
}


### USEFUL HELPERS ###

# write contents to an existing file
# fails if the file is not empty and it's contents differs
set_contents() {
   local contents="$1"
   local path="$2"
   [ ! -w "$path" ] && fail "file '$path' is not writable or doesn't exist"
   local current="` cat "$path" `"
   [ $? != 0 ] && fail "can't read file '$path'"
   [ -s "$path" -a "$contents" != "$current" ] && fail "file '$path' already contains something else"
   echo "$contents" > "$path"
}

add_line() {
   local line="$1"
   local path="$2"
   quiet head -n 1 "$path" || fail "can't read file '$path'"
   if ! quiet grep -F "$line" "$path"; then
     echo "$line" >> "$path" || fail "can't write to file '$path'"
   else
     info "already"
   fi
}

append_line() {
   local line="$1"
   local path="$2"
   quiet tail -n 1 "$path" || fail "can't read file '$path'"
   if [ "` tail -n 1 "$path" `" != "$line" ]; then
     echo "$line" >> "$path" || fail "can't write to file '$path'"
   else
     info "already"
   fi
}

comment_line_matching() {
   local match="$1"
   local path="$2"
   [ ! -f "$path" ] && fail "file '$path' not found"
   sed -i -r -e 's/^([^#]*'$match'.*)$/#\1/' "$path"
}

# WARN: gem_install is provided by RVM and it takes precedence! therefore this is install_gem
install_gem() {
   while [ -n "$1" ]; do
     if ! gem list "$1" | grep -q -e "^$1 "; then
       gem install "$1" || fail "can't install gem"
     else
       info "already"
     fi
     shift
   done
}

rpm_is_installed() {
   for i in `rpm -q "$1"`; do
      version="${i##$1}"
      if echo "$version" | egrep -q -e "^-[0-9]"; then
        return 0
      fi
   done
   return 1
}

only_user() {
   if [ "$USER" != "$1" ]; then
      fail "only user '$1' can run the blebook, you are $USER"
   fi
}

prepend_line() {
   local line="$1"
   local path="$2"
   quiet head -n 1 "$path" || fail "can't read file '$path'"
   if [ "` head -n 1 "$path" `" != "$line" ]; then
     sed -i "1i $line" "$path" || fail "can't edit file '$path'"
   else
     info "already"
   fi
}

remove_line_matching() {
   local match="$1"
   local path="$2"
   [ ! -f "$path" ] && fail "file '$path' not found"
   sed -i "\\$line\\d" "$path" || fail "can't edit file '$path'"
}

replace_matching() {
   local match="$1"
   local replace="$2"
   local path="$3"
   [ ! -f "$path" ] && fail "file '$path' not found"
   sed -i "s\\$match\\$replace\\g" "$path"
}

replace_line_matching() {
   local match="$1"
   local replace="$2"
   local path="$3"
   [ ! -f "$path" ] && fail "file '$path' not found"
   sed -i "s\\.*$match.*\\$replace\\g" "$path"
}

symlink() {
  local src=$1
  local dest=$2
  if test -L "$2"; then
    local curr="`readlink "$2"`"
    if [ "$curr" != "$1" ]; then
       fail "symlink exists already, but points to different location: $curr (should $2)"
    fi
    info "already"
  else
    ln -s "$1" "$2" || fail "can't create symlink"
  fi
}

timeout() {
   local time=$1; shift
   preserveEnvironment
   if ! /usr/bin/env timeout "$time" "${_BASHIBLE}" -- "$@"; then
      fail "timeout expired"
   fi
}

uncomment_line_matching() {
   local match="$1"
   local path="$2"
   [ ! -f "$path" ] && fail "file '$path' not found"
   sed -i -r -e 's/^ *#(.*?'$match'.*)$/\1/' "$path"
}

var_is_empty() {
   [ -z "`eval echo "$""$1"`" ]
}

# wait_for_tcp 10.0.3.188:80 up
# wait_for_tcp 10.0.3.188:80 down
wait_for_tcp() {
  local what="$1"
  local up="$2"
  if [ "$up" = up ]; then
     while ! netstat -lnt | grep "$what" | grep -q 'LISTEN'; do sleep 1; done
  elif [ "$up" = down ]; then
     while netstat -lnt | grep "$what" | grep -q 'LISTEN'; do sleep 1; done
  else
     fail "wait for '$up'? (expected up|down)"
  fi
  return 0
}

yum_install() {
   while [ -n "$1" ]; do
     if ! rpm_is_installed "$1"; then
        info "$1 seems to be not installed yet"
        yum install -y "$1" || fail "can't install $1"
     else
        info "$1 already"
     fi
     shift
   done
}


#### SETUP VARIABLES ####

_BASHIBLE=`readlink -e "$0"` # the bashible script itself
[ -z "${_BASHIBLE}" ] && fail "can't get _BASHIBLE; is readlink command present?"
_HOSTNAME=`hostname`
[ -z "${_HOSTNAME}" ] && fail "got no hostname"
_BLOCKS_STARTED=0     # zero before any block started
_SKIP=0               # skipping mode? reseted on next block
_BLEBOOK=''           # script to be executed
_BASE_DIR=''          # current base dir for blocks in a playbook
_ORIG_BASE_DIR=''     # orig base dir when a playbook has been called
_IS_CHILD=''          # 1 if this blebook is a sub-blebook
_NAV=''               # navigation when calling sub-blebook(s)
_PRESERVED='PATH:TAGS:_CALLED:_IMPORTED:_NOTIFY:' # preserved env variables; _PRESERVED itself is not preserved, must be explicitly declared in every blebook
_ENVREPEAT=()         # used for copying preserved environment variables over sudo or a command

# when called internally to run a sudoed command
if [ "$1" = "--" ]; then

  shift

  # first re-import all imported files
  IFS=':'; for i in $_IMPORTED; do
     if [ -n "$i" ]; then
        source "$i" || fail "problem while re-importing $i"
     fi
  done
  IFS=$' \t\n'

  # finally run the command; environment variables are included in the command
  # (built by the preserveEnvironment)
  "$@"

# when a help is requested
elif [ "$1" = -h -o "$1" = --help ]; then

  help

# when a blebook passed as the first parameter
elif [ -n "$1" ]; then

  _IMPORTED=':'            # imported files (re-sourced after sudo)

  if which tempfile >/dev/null; then
     _NOTIFY=`tempfile`    # will be called at the end
     _CALLED=`tempfile`    # already called playbooks
  else
     _NOTIFY=/tmp/bashible-$$.notify
     _CALLED=/tmp/bashible-$$.called
  fi

  # process the blebook
  call "$1"

  # at the end call notified commands
  while read path ; do
    call "$path"
  done < "${_NOTIFY}"

  # cleanup
  rm "${_CALLED}"
  rm "${_NOTIFY}"

else

  help

fi
